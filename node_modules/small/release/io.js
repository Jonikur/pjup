/// <reference path="../definitions/ref.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Vinyl = require('vinyl');
var Promise = require('bluebird');

// import path = require('path');
var fs = require('fs');
var stream = require('stream');
var events = require('events');

var ReadOperation;
(function (ReadOperation) {
    ReadOperation[ReadOperation["FILE_EXISTS"] = 0] = "FILE_EXISTS";
    ReadOperation[ReadOperation["DIRECTORY_EXISTS"] = 1] = "DIRECTORY_EXISTS";
    ReadOperation[ReadOperation["READ_FILE"] = 2] = "READ_FILE";
})(ReadOperation || (ReadOperation = {}));

function normalizePath(path) {
    if (!path)
        return path;
    return path.toLowerCase().replace(/\\/, '/');
}
exports.normalizePath = normalizePath;
function pathsEqual(a, b) {
    return exports.normalizePath(a) === exports.normalizePath(b);
}
exports.pathsEqual = pathsEqual;

var NodeIO = (function () {
    function NodeIO(cwd) {
        if (typeof cwd === "undefined") { cwd = process.cwd(); }
        this.cwd = cwd;
    }
    NodeIO.prototype.fileExists = function (path) {
        return new Promise(function (resolve, reject) {
            fs.stat(path, function (err, res) {
                if (err)
                    return reject(err);

                if (!res)
                    resolve(false);

                resolve(res.isFile());
            });
        });
    };

    NodeIO.prototype.directoryExists = function (path) {
        return new Promise(function (resolve, reject) {
            fs.stat(path, function (err, res) {
                if (err)
                    return reject(err);

                if (!res)
                    resolve(false);

                resolve(res.isDirectory());
            });
        });
    };

    NodeIO.prototype.readFile = function (path) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            fs.readFile(path, function (err, res) {
                if (err)
                    return reject(err);
                resolve(new Vinyl({
                    path: path,
                    contents: res,
                    cwd: _this.cwd
                }));
            });
        });
    };

    NodeIO.prototype.writeFile = function (file) {
        return new Promise(function (resolve, reject) {
            fs.writeFile(file.path, file.contents, function (err) {
                if (err)
                    return reject(err);

                resolve(true);
            });
        });
    };
    return NodeIO;
})();
exports.NodeIO = NodeIO;

var StreamIO = (function (_super) {
    __extends(StreamIO, _super);
    function StreamIO() {
        var _this = this;
        _super.call(this);
        this._files = [];
        this._queuedReads = [];

        this.stream = new StreamIO.DuplexStream(function (file) {
            _this._addFile(file);
        }, function () {
            _this._end();
        });
    }
    StreamIO.prototype._findLocalFile = function (path) {
        for (var i = 0; i < this._files.length; ++i) {
            var file = this._files[i];
            if (exports.pathsEqual(file.path, path))
                return file;
        }
        return undefined;
    };
    StreamIO.prototype._addFile = function (file) {
        this._files.push(file);

        this._queuedReads = this._queuedReads.filter(function (read) {
            if (exports.pathsEqual(read.path, file.path)) {
                switch (read.operation) {
                    case 0 /* FILE_EXISTS */:
                        read.resolve(true);
                        break;
                    case 2 /* READ_FILE */:
                        read.resolve(file);
                        break;
                }
                return false;
            }
            var normalizedPath = exports.normalizePath(read.path);
            if (read.operation === 1 /* DIRECTORY_EXISTS */ && exports.normalizePath(file.path).substr(0, normalizedPath.length) === normalizedPath) {
                read.resolve(true);
                return false;
            }

            return true;
        });

        this.emit('addFile', undefined, file);
    };
    StreamIO.prototype._end = function () {
        this._finished = true;
        this._queuedReads.forEach(function (read) {
            var err = new Error('ENOENT, no such file or directory, ' + read.path);
            err.code = 'ENOENT';
            read.reject(err);
        });
        this._queuedReads = [];
        this.emit('end');
    };

    StreamIO.prototype.fileExists = function (path) {
        var _this = this;
        if (this._findLocalFile(path)) {
            return Promise.resolve(true);
        } else if (this._finished) {
            return Promise.resolve(false);
        } else {
            return new Promise(function (resolve, reject) {
                _this._queuedReads.push({
                    path: path,
                    operation: 0 /* FILE_EXISTS */,
                    reject: reject,
                    resolve: resolve
                });
            });
        }
    };
    StreamIO.prototype.directoryExists = function (path) {
        var _this = this;
        var normalizedPath = exports.normalizePath(path);
        if (normalizedPath.substr(normalizedPath.length - 1) !== '/') {
            normalizedPath += '/';
            path += '/';
        }

        for (var i = 0; i < this._files.length; ++i) {
            var file = this._files[i];
            if (exports.normalizePath(file.path.substr(0, path.length)) === normalizedPath) {
                return Promise.resolve(true);
            }
        }

        if (this._finished) {
            return Promise.resolve(false);
        } else {
            return new Promise(function (resolve, reject) {
                _this._queuedReads.push({
                    path: normalizedPath,
                    operation: 1 /* DIRECTORY_EXISTS */,
                    reject: reject,
                    resolve: resolve
                });
            });
        }
    };

    StreamIO.prototype.readFile = function (path) {
        var _this = this;
        var file = this._findLocalFile(path);

        if (file) {
            return Promise.resolve(file);
        } else if (this._finished) {
            var err = new Error('ENOENT, no such file or directory, ' + path);
            err.code = 'ENOENT';
            return Promise.reject(err);
        } else {
            return new Promise(function (resolve, reject) {
                _this._queuedReads.push({
                    path: path,
                    operation: 2 /* READ_FILE */,
                    reject: reject,
                    resolve: resolve
                });
            });
        }
    };

    StreamIO.prototype.writeFile = function (file) {
        this.stream.push(file);
        return Promise.resolve(true);
    };
    return StreamIO;
})(events.EventEmitter);
exports.StreamIO = StreamIO;
(function (StreamIO) {
    var DuplexStream = (function (_super) {
        __extends(DuplexStream, _super);
        function DuplexStream(onFile, onEnd) {
            _super.call(this, { objectMode: true });
            this._onFile = onFile;
            this._onEnd = onEnd;
        }
        DuplexStream.prototype._write = function (file, encoding, cb) {
            if (typeof cb === "undefined") { cb = function (err) {
            }; }
            if (!file)
                return cb();

            if (file.isNull()) {
                cb();
                return;
            }
            if (file.isStream()) {
                return new Error('Stream not supported');
            }

            this._onFile(file);
            cb();
        };
        DuplexStream.prototype._read = function () {
        };

        DuplexStream.prototype.end = function (chunk, encoding, callback) {
            this._write(chunk, encoding, callback);
            this._onEnd();
        };
        return DuplexStream;
    })(stream.Duplex);
    StreamIO.DuplexStream = DuplexStream;
})(exports.StreamIO || (exports.StreamIO = {}));
var StreamIO = exports.StreamIO;

var HybridIO = (function () {
    function HybridIO(mainIO, altIO, altPaths, altReadOnly) {
        if (typeof altReadOnly === "undefined") { altReadOnly = false; }
        this.mainIO = mainIO;
        this.altIO = altIO;
        this.altPaths = altPaths;
        this.altReadOnly = altReadOnly;
    }
    HybridIO.prototype.needsAltIO = function (path) {
        path = exports.normalizePath(path);
        return this.altPaths.some(function (altPath) {
            altPath = exports.normalizePath(altPath);
            return path.substr(0, altPath.length) === altPath;
        });
    };

    HybridIO.prototype.fileExists = function (path) {
        if (this.needsAltIO(path)) {
            return this.altIO.fileExists(path);
        } else {
            return this.mainIO.fileExists(path);
        }
    };
    HybridIO.prototype.directoryExists = function (path) {
        if (this.needsAltIO(path)) {
            return this.altIO.directoryExists(path);
        } else {
            return this.mainIO.directoryExists(path);
        }
    };

    HybridIO.prototype.readFile = function (path) {
        if (this.needsAltIO(path)) {
            return this.altIO.readFile(path);
        } else {
            return this.mainIO.readFile(path);
        }
    };
    HybridIO.prototype.writeFile = function (file) {
        if (this.needsAltIO(file.path) && !this.altReadOnly) {
            return this.altIO.writeFile(file);
        } else {
            return this.mainIO.writeFile(file);
        }
    };
    return HybridIO;
})();
exports.HybridIO = HybridIO;
