/// <reference path="../definitions/ref.d.ts" />
var uglify = require('uglify-js');

var exportNode = require('./exportNode');
var importNode = require('./importNode');

function matchExportsAlias(node, isTopLevel) {
    // this
    if (node instanceof uglify.AST_This && isTopLevel) {
        return {
            style: 2 /* This */,
            dotArray: [],
            exportAST: node,
            ast: node
        };
    }

    // exports
    if (node instanceof uglify.AST_SymbolRef) {
        var nodeVar = node;
        if (nodeVar.thedef.name === 'exports' && nodeVar.thedef.undeclared) {
            return {
                style: 0 /* Exports */,
                dotArray: [],
                exportAST: nodeVar,
                ast: nodeVar
            };
        }
    }

    if (node instanceof uglify.AST_PropAccess) {
        var nodeAccess = node;

        // module.exports
        if (nodeAccess.expression instanceof uglify.AST_SymbolRef && nodeAccess.property === 'exports') {
            var expressionVal = nodeAccess.expression;

            if (expressionVal.thedef.name === 'module' && expressionVal.thedef.undeclared) {
                return {
                    style: 1 /* ModuleExports */,
                    dotArray: [],
                    exportAST: nodeAccess,
                    ast: nodeAccess
                };
            }
        }

        // [some exports style].[property]
        var exportAlias = exports.matchExportsAlias(nodeAccess.expression, isTopLevel);
        if (exportAlias) {
            if (typeof nodeAccess.property === 'string') {
                return {
                    style: exportAlias.style,
                    dotArray: exportAlias.dotArray.concat([nodeAccess.property]),
                    exportAST: exportAlias.exportAST,
                    ast: nodeAccess
                };
            }
        }
    }
}
exports.matchExportsAlias = matchExportsAlias;

function walkAst(f) {
    var impTopIndex = 0;
    var expTopIndex = 0;

    var handleExportTopLevel = function (exp, isTop) {
        exp.topLevel = isTop;
        if (isTop) {
            exp.topLevelIndex = expTopIndex++;
        }
    };

    var walker = new uglify.TreeWalker(function (node, descend) {
        var isTop = walker.find_parent(uglify.AST_Lambda) ? false : true;

        // imports
        if (node instanceof uglify.AST_Call) {
            var nodeCall = node;

            if (nodeCall.expression instanceof uglify.AST_SymbolRef && nodeCall.args.length === 1) {
                var funcVar = nodeCall.expression;

                if (funcVar.thedef.name === 'require' && funcVar.thedef.undeclared) {
                    var arg = nodeCall.args[0];

                    if (!(arg instanceof uglify.AST_String)) {
                        throw new Error('Statements in require calls are not allowed.');
                    }

                    var imp;
                    if (parent instanceof uglify.AST_VarDef) {
                        // TODO: imports with properties, like var func require('name').someObj.someFunc;
                        var parentVar = parent;

                        var impSimple = new importNode.SimpleImport();

                        impSimple.ast = parentVar;
                        impSimple.importAst = nodeCall;
                        impSimple.dotArray = [];
                        impSimple.varAst = parentVar.name;

                        impSimple.safe = true;

                        imp = impSimple;
                    } else {
                        imp = new importNode.Import();
                        imp.ast = nodeCall;
                        imp.importAst = nodeCall;

                        imp.safe = false;
                    }

                    imp.conditional = (walker.find_parent(uglify.AST_Block) || walker.find_parent(uglify.AST_StatementWithBody) || walker.find_parent(uglify.AST_Conditional) || walker.find_parent(uglify.AST_Binary)) ? false : true;
                    imp.safe = imp.safe && !imp.conditional;

                    imp.topLevel = isTop;
                    if (isTop) {
                        imp.topLevelIndex = impTopIndex++;
                    }
                    imp.relativePath = arg.value;

                    f.importNodes.push(imp);
                    // if (arg instanceof uglify.AST_String) {
                    // 	var argStr = <uglify.AST_String> arg;
                    // }
                }
            }
        }

        // exports
        var match = exports.matchExportsAlias(node, isTop);
        if (!match)
            return;

        var parent = walker.parent();

        if (parent instanceof uglify.AST_Assign) {
            var parentAssign = parent;
            if (match.dotArray.length === 0) {
                if (match.style !== 1 /* ModuleExports */) {
                    throw new Error('Use "module.exports = " for export assignments instead of "exports = " or "this = "');
                }
                var expF = new exportNode.FullExport();
                expF.style = match.style;
                expF.ast = parentAssign;
                expF.astLeft = match.ast;
                expF.exportAst = match.exportAST;
                expF.astRight = parentAssign.right;

                expF.safe = (walker.find_parent(uglify.AST_Block) || walker.find_parent(uglify.AST_StatementWithBody)) ? false : true;

                handleExportTopLevel(expF, isTop);

                f.exportNodes.push(expF);

                return true;
            } else {
                var expS = new exportNode.SingleExport();
                expS.style = match.style;
                expS.ast = parentAssign;
                expS.astLeft = match.ast;
                expS.exportAst = match.exportAST;
                expS.astRight = parentAssign.right;

                expS.dotArray = match.dotArray;

                expS.safe = (walker.find_parent(uglify.AST_Block) || walker.find_parent(uglify.AST_StatementWithBody)) ? false : true;

                handleExportTopLevel(expS, isTop);

                f.exportNodes.push(expS);
                return true;
            }
        } else {
            var expU = new exportNode.UnknownExport();
            expU.style = match.style;
            expU.ast = node;
            expU.exportAst = match.exportAST;

            expU.safe = false;

            handleExportTopLevel(expU, isTop);

            f.exportNodes.push(expU);
            return true;
        }
    });

    var walkerSafety = new uglify.TreeWalker(function (node, descend) {
        // import
        var def;

        if (node instanceof uglify.AST_VarDef) {
            var nodeVarDef = node;
            def = nodeVarDef.name.thedef;
        } else if (node instanceof uglify.AST_Assign) {
            var nodeAssign = node;
            if (nodeAssign.left instanceof uglify.AST_SymbolVar) {
                var nodeLeftVar = nodeAssign.left;
                def = nodeLeftVar.thedef;
            }
        }

        if (def) {
            for (var i = 0; i < f.importNodes.length; ++i) {
                var imp = f.importNodes[i];
                if (imp instanceof importNode.SimpleImport) {
                    var impSimple = imp;

                    if (!impSimple.safe)
                        continue;
                    if (impSimple.varAst.thedef !== def)
                        continue;

                    if (impSimple.ast === node)
                        continue;

                    impSimple.safe = false;
                }
            }
        }
    });
    f.ast.walk(walker);
    f.ast.walk(walkerSafety);

    // export safety
    var unknownExps = f.getUnknownExportNodes();
    var singleExps = f.getSingleExportNodes();
    var fullExps = f.getFullExportNodes();

    var expSafe;

    if (unknownExps.length !== 0) {
        expSafe = false;
    } else if (fullExps.length === 1) {
        if (singleExps.length >= 1) {
            expSafe = false;
        } else {
            expSafe = true;
        }
    } else if (fullExps.length >= 2) {
        expSafe = false;
    }

    if (expSafe === false || expSafe === true) {
        for (var i = 0; i < f.exportNodes.length; ++i) {
            f.exportNodes[i].safe = expSafe;
        }
    } else {
        for (var i = 0; i < singleExps.length; ++i) {
            var exp = singleExps[i];

            if (exp.safe === false)
                continue;

            if (singleExps.filter(function (item) {
                return item.dotArray[0] === exp.dotArray[0];
            }).length === 1) {
                exp.safe = true;
            } else {
                exp.safe = false;
            }
        }
    }
}
exports.walkAst = walkAst;
